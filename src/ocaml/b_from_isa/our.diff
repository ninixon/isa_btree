--- gen_our.ml	2017-02-08 16:27:05.236585309 +0000
+++ our.ml	2017-02-08 16:29:18.632334128 +0000
@@ -1,3 +1,11 @@
+let string_of_chars chars = chars|>List.map (String.make 1)|>String.concat ""
+
+type any_t
+
+let any_ref = ref ((Obj.magic 1):any_t)
+
+open Gen_isa
+
 module Util : sig
   type ('a, 'b) rresult = Ok of 'a | Error of 'b
   val rev_apply : 'a -> ('a -> 'b) -> 'b
@@ -21,7 +29,7 @@ let rec unzip
   xs = (rev_apply xs (List.map Product_Type.fst),
          rev_apply xs (List.map Product_Type.snd));;
 
-let rec failwitha x = failwith "undefined";;
+let rec failwitha x = x|>failwith;;
 
 let rec split_at n xs = (List.take n xs, List.drop n xs);;
 
@@ -41,7 +49,10 @@ let rec split_at_3
     (List.take n xs,
       (List.nth xs n, List.drop (Arith.plus_nat n Arith.one_nat) xs));;
 
-let rec assert_true arg b = b;;
+let rec assert_true arg b = (
+  let _ = any_ref := ((Obj.magic arg):any_t) in
+  if b then b else failwith "assert_true")
+;;
 
 let rec impossible1 x = failwitha "";;
 
@@ -89,13 +100,15 @@ let rec fmap_error
 
 end;;
 
-module Constants : sig
+
+
+module type Constants_t = sig
   type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf
   val max_leaf_size : Arith.nat
   val max_node_keys : Arith.nat
   val min_leaf_size : Arith.nat
   val min_node_keys : Arith.nat
-end = struct
+end (*= struct
 
 type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf;;
 
@@ -107,16 +120,17 @@ let min_leaf_size : Arith.nat = Util.fai
 
 let min_node_keys : Arith.nat = Util.failwitha "FIXME";;
 
-end;;
 
-module Key_value_types : sig
-  type key
+end;; *)
+
+module type Key_value_types_t = sig
+  type key [@@deriving yojson]
   val equal_keya : key -> key -> bool
   val equal_key : key HOL.equal
-  type value_t
+  type value_t [@@deriving yojson]
   val equal_value_t : value_t HOL.equal
   val key_ord : key -> key -> Arith.int
-end = struct
+end (*= struct
 
 type key = Private_key of Arith.nat;;
 
@@ -133,17 +147,17 @@ let equal_value_t = ({HOL.equal = equal_
 
 let rec key_ord k1 k2 = Util.failwitha "key_ord";;
 
-end;;
+end;; *)
 
-module Store : sig
-  type page = Page of Arith.nat
-  type page_ref = Page_ref of Arith.nat
-  type store = Store of (page_ref -> page)
+module type Store_t = sig
+  type page
+  type page_ref [@@deriving yojson]
+  type store 
   type store_error
   val free : page_ref list -> (unit, store, store_error) Monad.m_t
   val alloc : page -> (page_ref, store, store_error) Monad.m_t
   val page_ref_to_page : page_ref -> (page, store, store_error) Monad.m_t
-end = struct
+end (* = struct
 
 type page = Page of Arith.nat;;
 
@@ -159,14 +173,16 @@ let rec alloc p = Util.failwitha "FIXME"
 
 let rec page_ref_to_page p = Util.failwitha "FIXME";;
 
-end;;
+end;; *)
 
-module Frame_types : sig
+module type Frame_types_t = sig
+  module Store : Store_t
+  module Key_value_types : Key_value_types_t
   type pframe = Node_frame of (Key_value_types.key list * Store.page_ref list) |
-    Leaf_frame of (Key_value_types.key * Key_value_types.value_t) list
+    Leaf_frame of (Key_value_types.key * Key_value_types.value_t) list [@@deriving yojson]
   val frame_to_page : pframe -> Store.page
   val page_to_frame : Store.page -> pframe
-end = struct
+end (* = struct
 
 type pframe = Node_frame of (Key_value_types.key list * Store.page_ref list) |
   Leaf_frame of (Key_value_types.key * Key_value_types.value_t) list;;
@@ -175,7 +191,13 @@ let rec frame_to_page x = Util.failwitha
 
 let rec page_to_frame x = Util.failwitha "FIXME" x;;
 
-end;;
+end;; *)
+
+module Make = functor (Constants : Constants_t) -> functor (FT:Frame_types_t) -> struct
+
+module Frame_types = FT
+module Key_value_types = Frame_types.Key_value_types
+module Store = Frame_types.Store
 
 module Key_value : sig
   val key_eq : Key_value_types.key -> Key_value_types.key -> bool
@@ -300,11 +322,13 @@ let rec ordered_key_list
              (Arith.minus_nat (List.size_list ks)
                (Arith.nat_of_integer (Big_int.big_int_of_int 2))));;
 
+
 end;;
 
+
 module Tree : sig
   type tree = Node of (Key_value_types.key list * tree list) |
-    Leaf of (Key_value_types.key * Key_value_types.value_t) list
+    Leaf of (Key_value_types.key * Key_value_types.value_t) list[@@deriving yojson]
   val equal_tree : tree HOL.equal
   val equal_treea : tree -> tree -> bool
   val dest_Node : tree -> Key_value_types.key list * tree list
@@ -316,7 +340,7 @@ module Tree : sig
 end = struct
 
 type tree = Node of (Key_value_types.key list * tree list) |
-  Leaf of (Key_value_types.key * Key_value_types.value_t) list;;
+  Leaf of (Key_value_types.key * Key_value_types.value_t) list[@@deriving yojson];;
 
 let rec equal_tree () = ({HOL.equal = equal_treea} : tree HOL.equal)
 and equal_treea
@@ -488,10 +512,15 @@ let rec wellformed_tree
        let wf = b1 && (b2 && (b3 && (b4 && b5))) in
        wf);;
 
+
 end;;
 
+
 module Tree_stack : sig
-  type ('a, 'b) frame_ext
+  type ('a, 'b) frame_ext =
+  Frame_ext of
+    Key_value_types.key list * 'a list * 'a * Key_value_types.key list *
+      'a list * 'b [@@deriving yojson]
   val equal_frame_ext :
     'a HOL.equal -> 'b HOL.equal -> ('a, 'b) frame_ext HOL.equal
   val no_focus :
@@ -519,7 +548,7 @@ end = struct
 type ('a, 'b) frame_ext =
   Frame_ext of
     Key_value_types.key list * 'a list * 'a * Key_value_types.key list *
-      'a list * 'b;;
+      'a list * 'b [@@deriving yojson];;
 
 let rec equal_frame_exta _A _B
   (Frame_ext (f_ks1a, f_ts1a, f_ta, f_ks2a, f_ts2a, morea))
@@ -699,7 +728,7 @@ let rec r_frame_to_t_frame s = Tree_stac
 end;;
 
 module Find : sig
-  type find_state
+  type find_state[@@deriving yojson]
   val find_step :
     find_state -> (find_state, Store.store, Monad2.error) Monad.m_t
   val empty_btree :
@@ -725,7 +754,7 @@ type find_state =
         (Key_value_types.key *
           (Store.page_ref *
             ((Key_value_types.key * Key_value_types.value_t) list *
-              (Store.page_ref, unit) Tree_stack.frame_ext list))));;
+              (Store.page_ref, unit) Tree_stack.frame_ext list)))) [@@deriving yojson];;
 
 let rec find_step
   fs = (match fs
@@ -785,7 +814,7 @@ module Delete : sig
   type del_t =
     D_small_leaf of (Key_value_types.key * Key_value_types.value_t) list |
     D_small_node of (Key_value_types.key list * Store.page_ref list) |
-    D_updated_subtree of Store.page_ref
+    D_updated_subtree of Store.page_ref [@@deriving yojson]
   type d_state = D_down of (Find.find_state * Store.page_ref) |
     D_up of
       (del_t *
@@ -803,13 +832,13 @@ type 'a d12_t = D1 of 'a | D2 of ('a * (
 type del_t =
   D_small_leaf of (Key_value_types.key * Key_value_types.value_t) list |
   D_small_node of (Key_value_types.key list * Store.page_ref list) |
-  D_updated_subtree of Store.page_ref;;
+  D_updated_subtree of Store.page_ref [@@deriving yojson];;
 
 type d_state = D_down of (Find.find_state * Store.page_ref) |
   D_up of
     (del_t *
       ((Store.page_ref, unit) Tree_stack.frame_ext list * Store.page_ref))
-  | D_finished of Store.page_ref;;
+  | D_finished of Store.page_ref [@@deriving yojson];;
 
 let rec wf_d
   t0 s d =
@@ -1227,10 +1256,10 @@ end;;
 
 module Insert : sig
   type i_t = I1 of Store.page_ref |
-    I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref))
+    I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref)) [@@deriving yojson]
   type i_state_t = I_down of (Find.find_state * Key_value_types.value_t) |
     I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
-    I_finished of Store.page_ref
+    I_finished of Store.page_ref [@@deriving yojson]
   val insert_step :
     i_state_t -> (i_state_t, Store.store, Monad2.error) Monad.m_t
   val dest_i_finished : i_state_t -> Store.page_ref option
@@ -1244,11 +1273,11 @@ module Insert : sig
 end = struct
 
 type i_t = I1 of Store.page_ref |
-  I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref));;
+  I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref)) [@@deriving yojson];;
 
 type i_state_t = I_down of (Find.find_state * Key_value_types.value_t) |
   I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
-  I_finished of Store.page_ref;;
+  I_finished of Store.page_ref [@@deriving yojson];;
 
 let rec wf_d
   t0 s d =
@@ -1443,7 +1472,7 @@ module Insert_many : sig
     I1 of (Store.page_ref *
             (Key_value_types.key * Key_value_types.value_t) list)
     | I2 of ((Store.page_ref * (Key_value_types.key * Store.page_ref)) *
-              (Key_value_types.key * Key_value_types.value_t) list)
+              (Key_value_types.key * Key_value_types.value_t) list) [@@deriving yojson]
   type i_state_t =
     I_down of
       (Find.find_state *
@@ -1451,7 +1480,7 @@ module Insert_many : sig
           (Key_value_types.key * Key_value_types.value_t) list))
     | I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
     I_finished of
-      (Store.page_ref * (Key_value_types.key * Key_value_types.value_t) list)
+      (Store.page_ref * (Key_value_types.key * Key_value_types.value_t) list) [@@deriving yojson]
   val insert_step :
     i_state_t -> (i_state_t, Store.store, Monad2.error) Monad.m_t
   val dest_i_finished :
@@ -1468,7 +1497,7 @@ end = struct
 type i_t =
   I1 of (Store.page_ref * (Key_value_types.key * Key_value_types.value_t) list)
   | I2 of ((Store.page_ref * (Key_value_types.key * Store.page_ref)) *
-            (Key_value_types.key * Key_value_types.value_t) list);;
+            (Key_value_types.key * Key_value_types.value_t) list) [@@deriving yojson];;
 
 type i_state_t =
   I_down of
@@ -1477,7 +1506,7 @@ type i_state_t =
         (Key_value_types.key * Key_value_types.value_t) list))
   | I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
   I_finished of
-    (Store.page_ref * (Key_value_types.key * Key_value_types.value_t) list);;
+    (Store.page_ref * (Key_value_types.key * Key_value_types.value_t) list) [@@deriving yojson];;
 
 let rec step_up
   u = (match u with (_, []) -> Util.impossible1 "insert, step_up"
@@ -1637,4 +1666,8 @@ let rec dest_i_finished
 
 let rec mk_insert_state k v kvs r = I_down (Find.mk_find_state k r, (v, kvs));;
 
-end;;
\ No newline at end of file
+
+end;;
+
+
+end;; (* functor *)
