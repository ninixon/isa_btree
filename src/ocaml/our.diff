--- gen_our.ml	2016-12-02 11:05:37.355810718 +0000
+++ our.ml	2016-12-02 11:09:50.426379380 +0000
@@ -1,3 +1,11 @@
+let string_of_chars chars = chars|>List.map (String.make 1)|>String.concat ""
+
+type any_t
+
+let any_ref = ref ((Obj.magic 1):any_t)
+
+open Gen_isa
+
 module Util : sig
   type ('a, 'b) rresult = Ok of 'a | Error of 'b
   val rev_apply : 'a -> ('a -> 'b) -> 'b
@@ -20,7 +28,7 @@ let rec unzip
   xs = (rev_apply xs (List.map Product_Type.fst),
          rev_apply xs (List.map Product_Type.snd));;
 
-let rec failwitha x = failwith "undefined";;
+let rec failwitha x = x|>string_of_chars|>failwith;;
 
 let rec split_at n xs = (List.take n xs, List.drop n xs);;
 
@@ -43,7 +51,10 @@ let rec split_at_3
     (List.take n xs,
       (List.nth xs n, List.drop (Arith.plus_nat n Arith.one_nat) xs));;
 
-let rec assert_true arg b = b;;
+let rec assert_true arg b = (
+  let _ = any_ref := ((Obj.magic arg):any_t) in
+  if b then b else failwith "assert_true")
+;;
 
 let rec assert_truea b = assert_true () b;;
 
@@ -57,13 +68,15 @@ let rec from_to x y = List.upt x (Arith.
 
 end;;
 
-module Constants : sig
+
+
+module type Constants_t = sig
   type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf
   val max_leaf_size : Arith.nat
   val max_node_keys : Arith.nat
   val min_leaf_size : Arith.nat
   val min_node_keys : Arith.nat
-end = struct
+end (*= struct
 
 type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf;;
 
@@ -75,16 +88,17 @@ let min_leaf_size : Arith.nat = Util.fai
 
 let min_node_keys : Arith.nat = Util.failwitha ['F'; 'I'; 'X'; 'M'; 'E'];;
 
-end;;
 
-module Key_value_types : sig
-  type key
+end;; *)
+
+module type Key_value_types_t = sig
+  type key [@@deriving yojson]
   val equal_keya : key -> key -> bool
   val equal_key : key HOL.equal
-  type value_t
+  type value_t [@@deriving yojson]
   val equal_value_t : value_t HOL.equal
   val key_ord : key -> key -> Arith.int
-end = struct
+end (*= struct
 
 type key = Private_key of Arith.nat;;
 
@@ -101,15 +115,16 @@ let equal_value_t = ({HOL.equal = equal_
 
 let rec key_ord k1 k2 = Util.failwitha ['k'; 'e'; 'y'; '_'; 'o'; 'r'; 'd'];;
 
-end;;
+end;; *)
+    
 
-module Store : sig
-  type page = Page of Arith.nat
-  type page_ref = Page_ref of Arith.nat
-  type store = Store of (page_ref -> page)
+module type Store_t = sig
+  type page [@@deriving yojson]
+  type page_ref [@@deriving yojson]
+  type store [@@deriving yojson]
   type store_error
   val dest_Store : store -> page_ref -> page
-end = struct
+end(* = struct
 
 type page = Page of Arith.nat;;
 
@@ -122,14 +137,16 @@ type store_error = String;;
 let rec dest_Store x = let Store y = x in
                        y;;
 
-end;;
+end;;*)
 
-module Frame_types : sig
+module type Frame_types_t = sig
+  module Store : Store_t
+  module Key_value_types : Key_value_types_t
   type pframe = Node_frame of (Key_value_types.key list * Store.page_ref list) |
-    Leaf_frame of (Key_value_types.key * Key_value_types.value_t) list
-  val frame_to_page : pframe -> Store.page
+    Leaf_frame of (Key_value_types.key * Key_value_types.value_t) list[@@deriving yojson]
+  val frame_to_page : pframe -> Store.page 
   val page_to_frame : Store.page -> pframe
-end = struct
+end (*= struct
 
 type pframe = Node_frame of (Key_value_types.key list * Store.page_ref list) |
   Leaf_frame of (Key_value_types.key * Key_value_types.value_t) list;;
@@ -138,7 +155,12 @@ let rec frame_to_page x = Util.failwitha
 
 let rec page_to_frame x = Util.failwitha ['F'; 'I'; 'X'; 'M'; 'E'] x;;
 
-end;;
+end;;*)
+
+module Make = functor (Constants : Constants_t) -> functor (Frame_types:Frame_types_t) -> struct
+
+module Key_value_types = Frame_types.Key_value_types
+module Store = Frame_types.Store
 
 module Key_value : sig
   val key_eq : Key_value_types.key -> Key_value_types.key -> bool
@@ -246,11 +268,13 @@ let rec ordered_key_list
              (Arith.minus_nat (List.size_list ks)
                (Arith.nat_of_integer (Big_int.big_int_of_int 2))));;
 
+
 end;;
 
+
 module Tree : sig
   type tree = Node of (Key_value_types.key list * tree list) |
-    Leaf of (Key_value_types.key * Key_value_types.value_t) list
+    Leaf of (Key_value_types.key * Key_value_types.value_t) list[@@deriving yojson]
   val equal_tree : tree HOL.equal
   val equal_treea : tree -> tree -> bool
   val dest_Node : tree -> Key_value_types.key list * tree list
@@ -262,7 +286,7 @@ module Tree : sig
 end = struct
 
 type tree = Node of (Key_value_types.key list * tree list) |
-  Leaf of (Key_value_types.key * Key_value_types.value_t) list;;
+  Leaf of (Key_value_types.key * Key_value_types.value_t) list[@@deriving yojson];;
 
 let rec equal_tree () = ({HOL.equal = equal_treea} : tree HOL.equal)
 and equal_treea
@@ -434,10 +458,15 @@ let rec wellformed_tree
        let wf = b1 && (b2 && (b3 && (b4 && b5))) in
        wf);;
 
+
 end;;
 
+
 module Tree_stack : sig
-  type ('a, 'b) frame_ext
+  type ('a, 'b) frame_ext =
+  Frame_ext of
+    Key_value_types.key list * 'a list * 'a * Key_value_types.key list *
+      'a list * 'b [@@deriving yojson]
   val equal_frame_ext :
     'a HOL.equal -> 'b HOL.equal -> ('a, 'b) frame_ext HOL.equal
   val no_focus :
@@ -463,7 +492,7 @@ end = struct
 type ('a, 'b) frame_ext =
   Frame_ext of
     Key_value_types.key list * 'a list * 'a * Key_value_types.key list *
-      'a list * 'b;;
+      'a list * 'b [@@deriving yojson];;
 
 let rec equal_frame_exta _A _B
   (Frame_ext (f_ks1a, f_ts1a, f_ta, f_ks2a, f_ts2a, morea))
@@ -692,7 +721,7 @@ let rec page_ref_to_frame
 end;;
 
 module Find : sig
-  type find_state
+  type find_state[@@deriving yojson]
   val find_step :
     find_state ->
       Store.store -> Store.store * (find_state, Monad2.error) Util.rresult
@@ -714,7 +743,7 @@ type find_state =
       (Key_value_types.key *
         (Store.page_ref *
           ((Key_value_types.key * Key_value_types.value_t) list *
-            (Store.page_ref, unit) Tree_stack.frame_ext list)));;
+            (Store.page_ref, unit) Tree_stack.frame_ext list))) [@@deriving yojson];;
 
 let rec find_step
   fs = (match fs
@@ -767,12 +796,12 @@ module Delete : sig
   type del_t =
     D_small_leaf of (Key_value_types.key * Key_value_types.value_t) list |
     D_small_node of (Key_value_types.key list * Store.page_ref list) |
-    D_updated_subtree of Store.page_ref
+    D_updated_subtree of Store.page_ref [@@deriving yojson]
   type d_state = D_down of (Find.find_state * Store.page_ref) |
     D_up of
       (del_t *
         ((Store.page_ref, unit) Tree_stack.frame_ext list * Store.page_ref))
-    | D_finished of Store.page_ref
+    | D_finished of Store.page_ref [@@deriving yojson]
   val delete_step :
     d_state -> Store.store -> Store.store * (d_state, Monad2.error) Util.rresult
   val dest_d_finished : d_state -> Store.page_ref option
@@ -786,13 +815,13 @@ type 'a d12_t = D1 of 'a | D2 of ('a * (
 type del_t =
   D_small_leaf of (Key_value_types.key * Key_value_types.value_t) list |
   D_small_node of (Key_value_types.key list * Store.page_ref list) |
-  D_updated_subtree of Store.page_ref;;
+  D_updated_subtree of Store.page_ref [@@deriving yojson];;
 
 type d_state = D_down of (Find.find_state * Store.page_ref) |
   D_up of
     (del_t *
       ((Store.page_ref, unit) Tree_stack.frame_ext list * Store.page_ref))
-  | D_finished of Store.page_ref;;
+  | D_finished of Store.page_ref [@@deriving yojson];;
 
 let rec wf_d t0 s d = let (fs, _) = d in
                       Find.wellformed_find_state s t0 fs;;
@@ -1171,10 +1200,10 @@ end;;
 
 module Insert : sig
   type i_t = I1 of Store.page_ref |
-    I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref))
+    I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref)) [@@deriving yojson]
   type i_state_t = I_down of (Find.find_state * Key_value_types.value_t) |
     I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
-    I_finished of Store.page_ref
+    I_finished of Store.page_ref [@@deriving yojson]
   val insert_step :
     i_state_t ->
       Store.store -> Store.store * (i_state_t, Monad2.error) Util.rresult
@@ -1189,11 +1218,11 @@ module Insert : sig
 end = struct
 
 type i_t = I1 of Store.page_ref |
-  I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref));;
+  I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref)) [@@deriving yojson];;
 
 type i_state_t = I_down of (Find.find_state * Key_value_types.value_t) |
   I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
-  I_finished of Store.page_ref;;
+  I_finished of Store.page_ref [@@deriving yojson];;
 
 let rec wf_d t0 s d = let (fs, _) = d in
                       Find.wellformed_find_state s t0 fs;;
@@ -1366,4 +1395,8 @@ let rec wellformed_insert_state
     (match is with I_down a -> wf_d t0 s a | I_up a -> wf_u t0 k v s a
       | I_finished a -> wf_f t0 k v s a);;
 
-end;;
\ No newline at end of file
+
+end;;
+
+
+end;; (* functor *)
