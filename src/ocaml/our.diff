--- gen_our.ml	2016-12-01 18:23:05.946928791 +0000
+++ our.ml	2016-12-01 18:29:08.272330768 +0000
@@ -1,9 +1,17 @@
+let string_of_chars chars = chars|>List.map (String.make 1)|>String.concat ""
+
+type any_t
+
+let any_ref = ref ((Obj.magic 1):any_t)
+
+open Gen_isa
+
 module Util : sig
   type ('a, 'b) rresult = Ok of 'a | Error of 'b
   val rev_apply : 'a -> ('a -> 'b) -> 'b
   val unzip : ('a * 'b) list -> 'a list * 'b list
   val failwitha : char list -> 'a
   val split_at : Arith.nat -> 'a list -> 'a list * 'a list
   val dest_list : 'a list -> 'a * 'a list
   val dest_lista : 'a list -> 'a list * 'a
   val impossible : unit -> 'a
@@ -14,19 +22,19 @@ end = struct
 
 type ('a, 'b) rresult = Ok of 'a | Error of 'b;;
 
 let rec rev_apply x f = f x;;
 
 let rec unzip
   xs = (rev_apply xs (List.map Product_Type.fst),
          rev_apply xs (List.map Product_Type.snd));;
 
-let rec failwitha x = failwith "undefined";;
+let rec failwitha x = x|>string_of_chars|>failwith;;
 
 let rec split_at n xs = (List.take n xs, List.drop n xs);;
 
 let rec dest_list
   xs = (match xs
          with [] -> failwitha ['d'; 'e'; 's'; 't'; '_'; 'l'; 'i'; 's'; 't']
          | a :: b -> (a, b));;
 
 let rec dest_lista
@@ -37,77 +45,86 @@ let rec dest_lista
 
 let rec impossible
   uu = failwitha ['i'; 'm'; 'p'; 'o'; 's'; 's'; 'i'; 'b'; 'l'; 'e'];;
 
 let rec split_at_3
   n xs =
     (List.take n xs,
       (List.nth xs n, List.drop (Arith.plus_nat n Arith.one_nat) xs));;
 
-let rec assert_true arg b = b;;
+let rec assert_true arg b = (
+  let _ = any_ref := ((Obj.magic arg):any_t) in
+  if b then b else failwith "assert_true")
+;;
 
 let rec assert_truea b = assert_true () b;;
 
 end;;
 
-module Constants : sig
+
+
+module type Constants_t = sig
   type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf
   val max_leaf_size : Arith.nat
   val max_node_keys : Arith.nat
   val min_leaf_size : Arith.nat
   val min_node_keys : Arith.nat
-end = struct
+end (*= struct
 
 type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf;;
 
 let max_leaf_size : Arith.nat = Util.failwitha ['F'; 'I'; 'X'; 'M'; 'E'];;
 
 let max_node_keys : Arith.nat = Util.failwitha ['F'; 'I'; 'X'; 'M'; 'E'];;
 
 let min_leaf_size : Arith.nat = Util.failwitha ['F'; 'I'; 'X'; 'M'; 'E'];;
 
 let min_node_keys : Arith.nat = Util.failwitha ['F'; 'I'; 'X'; 'M'; 'E'];;
 
-end;;
+
+end;; *)
 
 module Prelude : sig
   val from_to : Arith.nat -> Arith.nat -> Arith.nat list
 end = struct
 
 let rec from_to x y = List.upt x (Arith.suc y);;
 
 end;;
 
-module Key_value_types : sig
-  type key
+module type Key_value_types_t = sig
+  type key [@@deriving yojson]
   val equal_keya : key -> key -> bool
   val equal_key : key HOL.equal
-  type value_t
+  type value_t [@@deriving yojson]
   val equal_value_t : value_t HOL.equal
   val key_ord : key -> key -> Arith.int
-end = struct
+end (*= struct
 
 type key = Private_key of Arith.nat;;
 
 let rec equal_keya (Private_key x) (Private_key ya) = Arith.equal_nat x ya;;
 
 let equal_key = ({HOL.equal = equal_keya} : key HOL.equal);;
 
 type value_t = Private_value of Arith.nat;;
 
 let rec equal_value_ta
   (Private_value x) (Private_value ya) = Arith.equal_nat x ya;;
 
 let equal_value_t = ({HOL.equal = equal_value_ta} : value_t HOL.equal);;
 
 let rec key_ord k1 k2 = Util.failwitha ['k'; 'e'; 'y'; '_'; 'o'; 'r'; 'd'];;
 
-end;;
+end;; *)
+
+module Make = functor (Constants : Constants_t) -> functor(Key_value_types: Key_value_types_t) -> struct
+
 
 module Key_value : sig
   val key_eq : Key_value_types.key -> Key_value_types.key -> bool
   val key_lt : Key_value_types.key -> Key_value_types.key -> bool
   val check_keys :
     Key_value_types.key option ->
       Key_value_types.key Set.set -> Key_value_types.key option -> bool
   val kvs_delete :
     Key_value_types.key ->
@@ -203,35 +220,37 @@ let rec ordered_key_list
          (Arith.nat_of_integer (Big_int.big_int_of_int 2)) ||
          List.pred_list
            (fun i ->
              key_lt (List.nth ks i)
                (List.nth ks (Arith.plus_nat i Arith.one_nat)))
            (Prelude.from_to Arith.zero_nat
              (Arith.minus_nat (List.size_list ks)
                (Arith.nat_of_integer (Big_int.big_int_of_int 2))));;
 
+
 end;;
 
+
 module Tree : sig
   type tree = Node of (Key_value_types.key list * tree list) |
-    Leaf of (Key_value_types.key * Key_value_types.value_t) list
+    Leaf of (Key_value_types.key * Key_value_types.value_t) list[@@deriving yojson]
   val equal_tree : tree HOL.equal
   val equal_treea : tree -> tree -> bool
   val dest_Node : tree -> Key_value_types.key list * tree list
   val tree_to_leaves :
     tree -> ((Key_value_types.key * Key_value_types.value_t) list) list
   val tree_to_kvs : tree -> (Key_value_types.key * Key_value_types.value_t) list
   val tree_to_keys : tree -> Key_value_types.key Set.set
   val wellformed_tree : Constants.min_size_t option -> tree -> bool
 end = struct
 
 type tree = Node of (Key_value_types.key list * tree list) |
-  Leaf of (Key_value_types.key * Key_value_types.value_t) list;;
+  Leaf of (Key_value_types.key * Key_value_types.value_t) list[@@deriving yojson];;
 
 let rec equal_tree () = ({HOL.equal = equal_treea} : tree HOL.equal)
 and equal_treea
   x0 x1 = match x0, x1 with Node x1, Leaf x2 -> false
     | Leaf x2, Node x1 -> false
     | Leaf x2, Leaf y2 ->
         List.equal_lista
           (Product_Type.equal_prod Key_value_types.equal_key
             Key_value_types.equal_value_t)
@@ -391,22 +410,27 @@ let rec wellformed_tree
     Util.assert_true (ms, t0)
       (let b1 = wf_size ms t0 in
        let b2 = wf_ks_rs t0 in
        let b3 = balanced t0 in
        let b4 = keys_consistent t0 in
        let b5 = keys_ordered t0 in
        let wf = b1 && (b2 && (b3 && (b4 && b5))) in
        wf);;
 
+
 end;;
 
+
 module Tree_stack : sig
-  type ('a, 'b) frame_ext
+  type ('a, 'b) frame_ext =
+  Frame_ext of
+    Key_value_types.key list * 'a list * 'a * Key_value_types.key list *
+      'a list * 'b [@@deriving yojson]
   val equal_frame_ext :
     'a HOL.equal -> 'b HOL.equal -> ('a, 'b) frame_ext HOL.equal
   val no_focus :
     (Tree.tree, unit) frame_ext list -> (Tree.tree, unit) frame_ext list
   val stack_map :
     ('a -> 'b) -> ('a, unit) frame_ext list -> ('b, unit) frame_ext list
   val dest_frame :
     ('a, unit) frame_ext ->
       (Key_value_types.key list * 'a list) *
@@ -420,19 +444,19 @@ module Tree_stack : sig
   val add_new_stk_frame :
     Key_value_types.key ->
       Key_value_types.key list * 'a list ->
         ('a, unit) frame_ext list -> ('a, unit) frame_ext list * 'a
 end = struct
 
 type ('a, 'b) frame_ext =
   Frame_ext of
     Key_value_types.key list * 'a list * 'a * Key_value_types.key list *
-      'a list * 'b;;
+      'a list * 'b [@@deriving yojson];;
 
 let rec equal_frame_exta _A _B
   (Frame_ext (f_ks1a, f_ts1a, f_ta, f_ks2a, f_ts2a, morea))
     (Frame_ext (f_ks1, f_ts1, f_t, f_ks2, f_ts2, more)) =
     List.equal_lista Key_value_types.equal_key f_ks1a f_ks1 &&
       (List.equal_lista _A f_ts1a f_ts1 &&
         (HOL.eq _A f_ta f_t &&
           (List.equal_lista Key_value_types.equal_key f_ks2a f_ks2 &&
             (List.equal_lista _A f_ts2a f_ts2 && HOL.eq _B morea more))));;
@@ -509,56 +533,57 @@ let rec add_new_stk_frame
     let a = Key_value.split_ks_rs k (ks, rs) in
     let (aa, b) = a in
     let (ks1, rs1) = aa in
     (fun (r, (ks2, rs2)) ->
       let (_, _) = stack_to_lu_of_child stk in
       let frm = Frame_ext (ks1, rs1, r, ks2, rs2, ()) in
       (frm :: stk, r))
       b;;
 
+
 end;;
 
+
 module Store : sig
-  type page
-  type page_ref
+  type page [@@deriving yojson]
+  type page_ref [@@deriving yojson]
   type store
-  type store_error
+  type store_error 
   val bind :
     ('a -> store -> store * ('b, 'c) Util.rresult) ->
       (store -> store * ('a, 'c) Util.rresult) ->
         store -> store * ('b, 'c) Util.rresult
   val fmap :
     ('a -> 'b) ->
       (store -> store * ('a, 'c) Util.rresult) ->
         store -> store * ('b, 'c) Util.rresult
   val alloc : page -> store -> store * (page_ref, store_error) Util.rresult
   val dest_Store : store -> page_ref -> page
   val fmap_error :
     ('a -> 'b) ->
       (store -> store * ('c, 'a) Util.rresult) ->
         store -> store * ('c, 'b) Util.rresult
   val page_ref_to_page :
     page_ref -> store -> store * (page, store_error) Util.rresult
 end = struct
 
-type page = Page of Arith.nat;;
+type page = Page of int[@@deriving yojson];;
 
-type page_ref = Page_ref of Arith.nat;;
+type page_ref = Page_ref of int[@@deriving yojson];;
 
 type store = Store of (page_ref -> page);;
 
 type store_error = String;;
 
 let rec bind
   f v = (fun s ->
           (match v s with (s1, Util.Ok y) -> f y s1
             | (s1, Util.Error x) -> (s1, Util.Error x)));;
-
 let rec fmap
   f m s =
     let (sa, r) = m s in
     (sa, (match r with Util.Ok y -> Util.Ok (f y)
            | Util.Error a -> Util.Error a));;
 
 let rec alloc p = Util.failwitha ['F'; 'I'; 'X'; 'M'; 'E'];;
 
 let rec dest_Store x = let Store y = x in
@@ -655,25 +680,28 @@ let rec bind f v = Store.bind f v;;
 
 let rec alloc
   p = Util.rev_apply (Store.alloc p)
         (Store.fmap_error (fun a -> Store_error a));;
 
 let rec return x = (fun s -> (s, Util.Ok x));;
 
 let rec se_to_e se = Store_error se;;
 
+
 let rec page_ref_to_frame
   r = Util.rev_apply (Frame.page_ref_to_frame r) (Store.fmap_error se_to_e);;
 
+
 end;;
 
+
 module Find : sig
-  type find_state
+  type find_state[@@deriving yojson]
   val find_step :
     find_state ->
       Store.store -> Store.store * (find_state, Monad.error) Util.rresult
   val mk_find_state : Key_value_types.key -> Store.page_ref -> find_state
   val dest_f_finished :
     find_state ->
       (Key_value_types.key *
         (Store.page_ref *
           ((Key_value_types.key * Key_value_types.value_t) list *
@@ -683,19 +711,19 @@ end = struct
 
 type find_state =
   F_down of
     (Key_value_types.key *
       (Store.page_ref * (Store.page_ref, unit) Tree_stack.frame_ext list))
   | F_finished of
       (Key_value_types.key *
         (Store.page_ref *
           ((Key_value_types.key * Key_value_types.value_t) list *
-            (Store.page_ref, unit) Tree_stack.frame_ext list)));;
+            (Store.page_ref, unit) Tree_stack.frame_ext list))) [@@deriving yojson];;
 
 let rec find_step
   fs = (match fs
          with F_down (k, (r, stk)) ->
            Util.rev_apply (Monad.page_ref_to_frame r)
              (Store.fmap
                (fun a ->
                  (match a
                    with Frame.Node_frame (ks, rs) ->
@@ -736,44 +764,44 @@ let rec wellformed_find_state
              (Tree.Leaf kvs,
                Util.rev_apply stk (Tree_stack.stack_map r_to_t))));;
 
 end;;
 
 module Delete : sig
   type del_t =
     D_small_leaf of (Key_value_types.key * Key_value_types.value_t) list |
     D_small_node of (Key_value_types.key list * Store.page_ref list) |
-    D_updated_subtree of Store.page_ref
+    D_updated_subtree of Store.page_ref [@@deriving yojson]
   type d_state = D_down of (Find.find_state * Store.page_ref) |
     D_up of
       (del_t *
         ((Store.page_ref, unit) Tree_stack.frame_ext list * Store.page_ref))
-    | D_finished of Store.page_ref
+    | D_finished of Store.page_ref [@@deriving yojson]
   val delete_step :
     d_state -> Store.store -> Store.store * (d_state, Monad.error) Util.rresult
   val dest_d_finished : d_state -> Store.page_ref option
   val mk_delete_state : Key_value_types.key -> Store.page_ref -> d_state
   val wellformed_delete_state :
     Tree.tree -> Key_value_types.key -> Store.store -> d_state -> bool
 end = struct
 
 type 'a d12_t = D1 of 'a | D2 of ('a * (Key_value_types.key * 'a));;
 
 type del_t =
   D_small_leaf of (Key_value_types.key * Key_value_types.value_t) list |
   D_small_node of (Key_value_types.key list * Store.page_ref list) |
-  D_updated_subtree of Store.page_ref;;
+  D_updated_subtree of Store.page_ref [@@deriving yojson];;
 
 type d_state = D_down of (Find.find_state * Store.page_ref) |
   D_up of
     (del_t *
       ((Store.page_ref, unit) Tree_stack.frame_ext list * Store.page_ref))
-  | D_finished of Store.page_ref;;
+  | D_finished of Store.page_ref [@@deriving yojson];;
 
 let rec wf_d t0 s d = let (fs, _) = d in
                       Find.wellformed_find_state s t0 fs;;
 
 let rec wf_f
   t0 k s r =
     let t = Frame.r_to_t s r in
     Tree.wellformed_tree (Some Constants.Small_root_node_or_leaf) t &&
       List.equal_lista
@@ -1136,45 +1164,47 @@ let rec dest_d_finished
 let rec mk_delete_state k r = D_down (Find.mk_find_state k r, r);;
 
 let rec wellformed_delete_state
   t0 k s ds =
     (match ds with D_down a -> wf_d t0 s a
       | D_up (fo, (stk, r)) ->
         wf_u t0 k s (fo, stk) && Tree.equal_treea (Frame.r_to_t s r) t0
       | D_finished a -> wf_f t0 k s a);;
 
+
 end;;
 
+
 module Insert : sig
   type i_t = I1 of Store.page_ref |
-    I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref))
+    I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref)) [@@deriving yojson]
   type i_state_t = I_down of (Find.find_state * Key_value_types.value_t) |
     I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
-    I_finished of Store.page_ref
+    I_finished of Store.page_ref [@@deriving yojson]
   val insert_step :
     i_state_t ->
       Store.store -> Store.store * (i_state_t, Monad.error) Util.rresult
   val dest_i_finished : i_state_t -> Store.page_ref option
   val mk_insert_state :
     Key_value_types.key ->
       Key_value_types.value_t -> Store.page_ref -> i_state_t
   val wellformed_insert_state :
     Tree.tree ->
       Key_value_types.key ->
         Key_value_types.value_t -> Store.store -> i_state_t -> bool
 end = struct
 
 type i_t = I1 of Store.page_ref |
-  I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref));;
+  I2 of (Store.page_ref * (Key_value_types.key * Store.page_ref)) [@@deriving yojson];;
 
 type i_state_t = I_down of (Find.find_state * Key_value_types.value_t) |
   I_up of (i_t * (Store.page_ref, unit) Tree_stack.frame_ext list) |
-  I_finished of Store.page_ref;;
+  I_finished of Store.page_ref [@@deriving yojson];;
 
 let rec wf_d t0 s d = let (fs, _) = d in
                       Find.wellformed_find_state s t0 fs;;
 
 let rec wf_f
   t0 k v s r =
     let t = Frame.r_to_t s r in
     Tree.wellformed_tree (Some Constants.Small_root_node_or_leaf) t &&
       List.equal_lista
@@ -1335,10 +1365,14 @@ let rec dest_i_finished
         | I_finished a -> Some a);;
 
 let rec mk_insert_state k v r = I_down (Find.mk_find_state k r, v);;
 
 let rec wellformed_insert_state
   t0 k v s is =
     (match is with I_down a -> wf_d t0 s a | I_up a -> wf_u t0 k v s a
       | I_finished a -> wf_f t0 k v s a);;
 
-end;;
\ No newline at end of file
+
+end;;
+
+
+end;;
