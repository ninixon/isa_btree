(*

lemma search_key_to_index: "
(search_key_to_index ks k = i) \<longrightarrow> i : set(subtree_indexes (ks,rs))
"
apply(force intro:FIXME)
done

lemma subtree_indexes_trichotomy: " 
i : set(subtree_indexes (ks,rs)) \<longrightarrow> 
(min_child_index < i & i < max_child_index(ks,rs)) | 
(i = min_child_index) | (i = max_child_index(ks,rs))"
apply(force intro:FIXME)
done

(* the easy case *)

lemma search_key_to_index_bound: "
(search_key_to_index ks k = i) & 
min_child_index < i &
i < max_child_index(ks,rs) \<longrightarrow> (
let (l,u) = get_lu_for_child ((ks,rs),i) in
check_keys l [k] u)"
apply(force intro: FIXME)
done

lemma lu_with_default_eq_lu: "
min_child_index < i & i < max_child_index(ks,rs) 
\<longrightarrow> (get_lu_for_child_with_parent_default x2 ((ks,rs),i) = get_lu_for_child ((ks,rs),i))"
apply(force intro:FIXME)
done

lemma get_parent_bounds_check_keys: "
wellformed_fts_1 (Fts_state (k, Node (ks, rs), ts)) \<Longrightarrow>
get_parent_bounds ts = (l1, u1) \<Longrightarrow>
check_keys l1 [k] u1
"
apply(simp add: get_parent_bounds_def)
apply(case_tac ts) apply(simp add: get_parent_bounds_def check_keys_def)
apply(simp)
apply(subgoal_tac "? n i x. a = Cnode(n,i,x)") prefer 2 apply(force intro:FIXME)
apply(elim exE, simp)
apply(simp add: wellformed_fts_1_def dest_cnode_t_def)
apply(force simp add: check_keys_def)
done


(* FIXME do we also want to include keys(rs!i) in the bound? *)
definition main_property :: "fts_state_t \<Rightarrow> bool" where
"main_property fts' = (
  let (k,t,ts) = dest_fts_state_t fts' in
  case ts of 
  Nil \<Rightarrow> True
  | cn#cns \<Rightarrow> (
    let (n,i,x) = dest_cnode_t cn in
    let (l,u) = x in
    check_keys l [k] u
  ))"

lemma main_lemma: "(
total_order_key_lte &
(step_fts fts = Some fts') &
wellformed_fts fts --> main_property fts')
"
apply(simp add: main_property_def)
apply(simp, intro allI impI, elim conjE)
apply(subgoal_tac "? k t ts. fts = Fts_state(k,t,ts)") prefer 2 apply(force intro:FIXME)
apply(elim exE, simp)
apply(simp add: step_fts_def)
apply(subgoal_tac "(? kvs. t = Leaf kvs) | (? ks rs. t = Node(ks,rs))") prefer 2 apply(force intro: FIXME)
apply(erule disjE) apply(force)
apply(elim exE, simp)
apply(subgoal_tac "? i. search_key_to_index ks k = i") prefer 2 apply(force)
apply(elim exE, simp)
apply(drule_tac t=fts' in sym) apply(simp)
apply(thin_tac "fts'=_")
apply(simp add: dest_cnode_t_def)
apply(subgoal_tac "
   ? l0 u0. get_lu_for_child_with_parent_default (get_parent_bounds ts) ((ks, rs), i) = (l0,u0)") prefer 2 apply(force)
apply(elim exE, simp)
(* this is the goal we want *)
apply(subgoal_tac "check_keys l0 [k] None & check_keys None [k] u0") apply(force intro:FIXME)
apply(rule conjI)
 (* want check_keys l0 [k] None; distinguish i=min_child from other case *)
 apply(subgoal_tac "(i = min_child_index) | (min_child_index < i & i \<le> max_child_index(ks,rs))") prefer 2 apply(force intro:FIXME)
 apply(elim disjE)
  (* i = min_child_index; so l0 is the lower bound of the parent *)
  apply(subgoal_tac "? l1 u1. get_parent_bounds ts = (l1,u1)") prefer 2 apply(force intro:FIXME)
  apply(elim exE,simp)
  apply(subgoal_tac "l0 = l1") prefer 2 apply(force intro:FIXME)
  apply(simp)
  apply(simp add: wellformed_fts_def ) apply(elim conjE)
  using check_keys_eq_ck_ck get_parent_bounds_check_keys apply blast
    
  (* min_child_index < i *)
  apply(force intro:FIXME)

  (* want check_keys None [k] u0 *)
  apply(subgoal_tac "? l1 u1. get_parent_bounds ts = (l1,u1)") prefer 2 apply(force intro:FIXME)
  apply(elim exE,simp)
  apply(subgoal_tac "(i = max_child_index(ks,rs)) | (min_child_index \<le> i & i < max_child_index(ks,rs))") prefer 2 apply(force intro:FIXME)
  apply(elim disjE)
  
   apply(subgoal_tac "u0 = u1") prefer 2 apply(force intro:FIXME)
   apply(simp)
   apply(simp add: wellformed_fts_def ) apply(elim conjE)
   using check_keys_eq_ck_ck get_parent_bounds_check_keys apply blast

   (* i < max_child_index *)
   apply(force intro: FIXME)
done 
*)



(* the following is about merging maps together; this must be in isa lib somewhere *)

definition set_as_map :: "('a*'b) set \<Rightarrow> ('a,'b) map \<Rightarrow> bool" where
"set_as_map xys f = (
(! a. (f a = None) = (~ (? b. (a,b) : xys))) 
  & (! a b. (f a = Some b) = ((a,b) : xys)))"

(* defining a function from a set *)
definition set_to_map :: "('a * 'b) set \<Rightarrow> ('a,'b) map" where
"set_to_map xys = (SOME f. set_as_map xys f)"

(* FIXME we don't need this? *)
lemma set_to_map_exists: "
(! a b b'. (a,b) : xys & (a,b') : xys \<longrightarrow> (b'=b)) \<longrightarrow> (set_as_map xys (set_to_map xys))"
apply(force intro:FIXME)
done

definition map_to_set :: "('a,'b) map \<Rightarrow> ('a * 'b) set" where
"map_to_set m = { (x,y). m x = Some y }"
