(* prefer lem2; k0 is located in the focus; proof by induction on ts; perhaps better to do this for the step case explicitly?*)
(*
definition lem1 :: "bool" where
"lem1 = (
  ! k0 f ts.
  let (k,l,t,u) = dest_fts_focus f in
  let (ks,rs) = ts_to_t0 ts |> dest_Some in
  (ts \<noteq> []) &
  wellformed_fts k0 (f,ts) & 
  k0 : tree_to_map (Node(ks,rs)) |> dom \<longrightarrow>
  k0 : tree_to_map t |> dom 
)"
*)

(* for find, the following is all we need, but may be preferable to prove something stronger needed
for insert and delete *)
(*
definition lem2 :: "bool" where you all very much for coming the other night: it was great to see you. Sadly we got a bit carried away by the liberation of not having a baby-sitter to get back to. Did at least
"lem2 = (! k0 f ts f' ts'.
  let (_,_,t,_) = dest_fts_focus f in
  let (_,_,t',_) = dest_fts_focus f' in
  wellformed_fts k0 (f,ts) &
  k0 : (t|>tree_to_map|>dom) &
  (step_fts (f,ts) = Some(f',ts')) \<longrightarrow>
  k0 : (t'|>tree_to_map|>dom)
)"
*)

(* want to talk about all the leaves... *)
(*
definition lem3 :: "bool" where
"lem3 = (! k0 f ts f' ts'.
  let (_,_,t,_) = dest_fts_focus f in
  let (_,_,t',_) = dest_fts_focus f' in
  wellformed_fts k0 (f,ts) &
  k0 : (t|>tree_to_map|>dom) &
  (step_fts (f,ts) = Some(f',ts')) \<longrightarrow>
  k0 : (t'|>tree_to_map|>dom)
)"
*)

(* this still talks about the focus
definition lem5 :: "bool" where
"lem5 = (! k0 f ts.
  wellformed_fts k0 (f,ts) \<longrightarrow> (
  let (k,_,t,_) = dest_fts_focus f in
  ? xs zs. 
    let t' = fts_reass (f,ts) in 
    (t' |> tree_to_leaves = xs@(tree_to_leaves t)@zs) & 
    (k0 : tree_to_map t' |> dom \<longrightarrow> k0 : tree_to_map t |> dom))
)"
*)

(* the lu separate leaves of focus from other leaves of reass *)
(*
definition lem6 :: "bool" where
"lem6 = (! k0 f ts.
  wellformed_fts k0 (f,ts) \<longrightarrow> (
    let (k,xs,l,t,u,zs) = dest_fts_focus f in
    ? xs zs. (
      let t' = fts_reass (f,ts) in 
      (t' |> tree_to_leaves = xs@(tree_to_leaves t)@zs) & 
      (* note None is functioning as +-infinity here, rather than <<dont care>> *)
      check_keys_2 (xs |> leaves_to_map|>dom) l {} u (zs|>leaves_to_map|>dom)))
)"  
*)

(* following should say that if we start with xs=zs={}, then the xs@(leaves of the focus)@zs are the leaves
of the original tree - ie the leaves are invariant; then we know the ordering on xs,leaves,zs, and we
also know the bound lu 

first show that step preserves wellformedness; then show it preserves leaves and check_keys_2

*)




definition lem7 :: "bool" where
"lem7 = (! f trns k0 t0 ts0 f0.
  (trns = { (s,s'). case s of None \<Rightarrow> s'=None | Some fts \<Rightarrow> step_fts fts = s' }) &
  f : (trace_set trns) &
  (tree_to_fts k0 t0 = (f0,ts0)) &
  (Some(f0,ts0) = f 0) 
  \<longrightarrow> (
  ! (n::nat). case f n of None \<Rightarrow> True | Some fn \<Rightarrow> (
  let (f_n,ts_n) = fn in
  let (k,xs,l,t,u,zs) = dest_fts_focus f0 in
  let (k,xs',l',t',u',zs') = dest_fts_focus f_n in
  let ks' = t'|>tree_to_map|>dom in (
  wellformed_fts k0 (f_n,ts_n)) \<longrightarrow> 
  check_keys_2 (xs'|>leaves_to_map|>dom) l' ks' u' (zs'|>leaves_to_map|>dom) &
  (xs'@(t'|>tree_to_leaves)@zs' = xs@(t|>tree_to_leaves)@zs))) 
)"

(* FIXME shouldn't this be part of wf_fts_focus? *)
definition focus_to_check_keys_2 :: "fts_focus_t \<Rightarrow> bool" where
"focus_to_check_keys_2 f = (
  let (k,xs',l',t',u',zs') = dest_fts_focus f in
  check_keys_2 (xs'|>leaves_to_map|>dom) l' ((t'|>tree_to_map|>dom)) u' (zs'|>leaves_to_map|>dom)
)"


definition lem8 :: "bool" where
"lem8 = (! ls P Q.
  ((% fts. let (f,ts) = fts in focus_to_check_keys_2 f) = P) &
  ((% fts. let (f,ts) = fts in focus_to_leaves f = ls) = Q) \<longrightarrow> 
  fts_invariant (% fts. P fts & Q fts)
)"


(* now we need a nice way of combining the invariants: given that we know wf is invariant, show P and Q assuming wf *)
definition lem9 :: "bool" where
"lem9 = (! k0 ls P Q W.
  ((% fts. wellformed_fts k0 fts) = W) &
  ((% fts. let (f,ts) = fts in focus_to_check_keys_2 f) = P) &
  ((% fts. let (f,ts) = fts in focus_to_leaves f = ls) = Q) \<longrightarrow>
  fts_invariant (% fts. W fts)  \<longrightarrow>
  fts_invariant (% fts. W fts & P fts & Q fts)
)"

(* how to get from lem9 to correctness of eg find? well, we have k bounded and the leaves are the same, so the maps are the same, and equal... *)

lemma btree_find_correct: "! trns f k0 t0 f0 ts0 v0.
(trns = { (s,s'). case s of None \<Rightarrow> s'=None | Some fts \<Rightarrow> step_fts fts = s' }) &
f : (trace_set trns) \<longrightarrow> (
(tree_to_fts k0 t0 = (f0,ts0)) &
(Some(f0,ts0) = f 0) &
(tree_to_map t0 k0 = v0) \<longrightarrow> (
! n f_n ts_n. (f (n::nat) = Some(f_n,ts_n)) \<longrightarrow>
(let (k,xs,l,t,u,zs) = dest_fts_focus f_n in
(tree_to_map t k0 = v0))))
"
sorry

(* FIXME next step to look at insert, using a lem7-like lemma *)

lemma dest_fts_focus_def_2: "dest_fts_focus (Focus(k,xs,l,t,u,zs)) = (k,xs,l,t,u,zs)"
apply(simp add: dest_fts_focus_def)
done

(* ts_to_t0 ------------------------------------ *)

(* get the initial tree from which the ts was formed *)
(*
definition ts_to_t0 :: "tree_stack_t \<Rightarrow> node_t option" where
"ts_to_t0 ts = (
  case ts of
  Nil \<Rightarrow> None
  | _ \<Rightarrow> ( 
    let cn = last ts in
    let (l,ks,rs,i,u) = dest_cnode cn in
    Some(ks,rs)))
"
*)



(* either go via leaves, or form the maps and merge them; here we merge; FIXME always go via leaves? try to avoid merging maps *)
function tree_to_map :: "Tree => (key,value_t) map" where
"tree_to_map t = (
  case t of Leaf kvs \<Rightarrow> (map_of kvs)
  | Node(ks,rs) \<Rightarrow> (
    let ms = List.map tree_to_map rs in
    maps_to_map (set(ms))))"
by auto
termination
  apply(force intro:FIXME)
  done

(* FIXME here we have lemmas about forming a map from leaves of a tree *)

(* the map from a tree is just the merge of the individual maps for the leaves, assuming the leaves are distinct *)
definition tree_to_map_leaves_to_map_b :: "bool" where
"tree_to_map_leaves_to_map_b = (! t.
  (nice_leaves (t|>tree_to_leaves)) \<longrightarrow> 
  (tree_to_map t = t |> tree_to_leaves |> leaves_to_map)
)"



(* wellformed_core ------------------------------------------ *)

definition wellformed_core :: "key \<Rightarrow> ms_t \<Rightarrow> core_t => bool" where
"wellformed_core k0 ms f = (
  let (k,xs,l,t,u,zs) = f|>dest_core in
  let b1 = wellformed_tree ms t in
  let b2 = check_keys_2 (xs|>leaves_to_map|>dom) l (set (k#(keys t))) u (zs|>leaves_to_map|>dom) in
  b1&b2&(k=k0))"
  
  
  
  (* stack reassembly ----------------------------------- *)

fun reass :: "key \<Rightarrow> Tree \<Rightarrow> tree_stack_t \<Rightarrow> Tree" where
"reass k0 t ts = (
  case ts of
  Nil \<Rightarrow> t
  | x#xs \<Rightarrow> (
    let nf2 = x|> split_node k0 in
    let (ts1,ts2) = (nf2|>nf_ts1,nf2|>nf_ts2) in
    let (_,(ks,_),_) = x in
    let t2 = Node(ks,ts1@[t]@ts2) in
    reass k0 t2 xs)
)"





(* lemmas ------------------------------------------------ *)

(* FIXME needed? *)
definition reass_tree_to_leaves_b :: bool where
"reass_tree_to_leaves_b = (! k0 ts t.
  ? xs zs. (reass k0 t ts) |> tree_to_leaves = xs@(tree_to_leaves t)@zs)"

  
  (* fts_reass ---------------------------------------- *)
definition fts_reass :: "fts_state_t \<Rightarrow> Tree" where
"fts_reass fts = (
  let (f,ts) = fts in
  let (k,xs,l,t,u,zs) = f|>dest_fts_focus|>dest_core in
  reass t ts
)"


(*
definition fts_invariant :: "(fts_state_t \<Rightarrow> bool) \<Rightarrow> bool" where
"fts_invariant P = (invariant fts_trans P)"
*)


(*
definition indexes_to_trees :: "Tree list \<Rightarrow> nat list \<Rightarrow> Tree list" where
"indexes_to_trees rs is = (is |> List.map (% i. rs!i))"
*)

definition subtree_indexes :: "node_t \<Rightarrow> nat list" where
"subtree_indexes node = (let (ks,rs) = node in from_to min_child_index (ks_to_max_child_index ks))"




(* bounds ----------------------------------------- *)

type_synonym bound_t = "(key option * key option)"  (* l,u *)



(* if the bound cb comes from a child, and one of the bounds is none, substitute with the relevant bound pb from the parent *)
definition with_parent_bound :: "bound_t \<Rightarrow> bound_t \<Rightarrow> bound_t" where
"with_parent_bound pb cb = (
  let (l1,u1) = cb in
  let (l2,u2) = pb in
  let l = (case l1 = None of True \<Rightarrow> l2 | _ \<Rightarrow> l1) in
  let u = (case u1 = None of True \<Rightarrow> u2 | _ \<Rightarrow> u1) in
  (l,u)
)"


(* lemmas ------------------------------------------- *)


definition wellformed_tree_nice_leaves_b :: "bool" where
"wellformed_tree_nice_leaves_b = (
  ! ms t.
    wellformed_tree ms t \<longrightarrow> nice_leaves (t|>tree_to_leaves))"

    (* bound from frame ---------------------------------------- *)


(* make sure we use the existing bound in case i is extremal *)
(*
definition nf_to_bound :: "key \<Rightarrow> nf_t \<Rightarrow> nf_t \<Rightarrow> bound_t" where
"nf_to_bound k0 p c = (
  let (_,_,kl,_,ku,_) = p |> dest_core in
  let (l,u) = c |> dest_coresplit_node k0 |> (% x. (x|>nf_kl,x|>nf_ku) ) in
  (l,u) |> with_parent_bound (lp,lu)
)"
*)



